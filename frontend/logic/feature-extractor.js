/* FILE: extensions/plugins/gesture-vision-plugin-gesture-studio/frontend/logic/feature-extractor.js */
const MIN_SAMPLES_FOR_STATISTICAL_RELEVANCE = 3;

// --- Vector Math Utilities (will be embedded in generated file) ---
const VectorUtils = {
  subtract: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z }),
  normalize: (v) => {
    const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    return mag > 1e-6 ? { x: v.x / mag, y: v.y / mag, z: v.z / mag } : { x: 0, y: 0, z: 0 };
  },
  dot: (v1, v2) => v1.x * v2.x + v1.y * v2.y + v1.z * v2.z,
};

export class FeatureExtractor {
  #gestureType;
  constructor(gestureType) {
    if (gestureType !== "hand" && gestureType !== "pose") {
      throw new Error("This feature extractor only supports 'hand' or 'pose' gestures.");
    }
    this.#gestureType = gestureType;
  }

  #calculateStats(values) {
    if (values.length < 2) return { mean: values[0] || 0, stdDev: 0, variation: 0 };
    const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / (values.length -1);
    const stdDev = Math.sqrt(variance);
    const variation = mean > 1e-6 ? stdDev / mean : Infinity;
    return { mean, stdDev, variation };
  }

  #getChirality(landmarks) {
    if (!landmarks || landmarks.length < 21) return 'unknown';
    return landmarks[17].x < landmarks[5].x ? 'right' : 'left';
  }
  
  /**
   * Generates a JS file for a DYNAMIC gesture based on calibrated distances.
   */
  generateDynamicGestureJsFileContent(definition) {
    const { metadata, landmark1, landmark2, minDistance, maxDistance } = definition;
    const checkFnName = metadata.type === 'pose' ? "checkPose" : "checkGesture";
    
    // Default to hand landmarks 5 to 8, or shoulder landmarks 11 to 12 for pose
    const [ref1, ref2, knownDist] = metadata.type === 'hand' 
      ? [5, 8, 9.0] // INDEX_FINGER_MCP to INDEX_FINGER_TIP, assumed 9cm
      : [11, 12, 25.0]; // LEFT_SHOULDER to RIGHT_SHOULDER, assumed 25cm

    return `// Custom Gesture: ${metadata.name} (Type: ${metadata.type})
// Description: ${metadata.description}
// Generated by GestureVision Studio on ${new Date().toLocaleDateString()}
export const metadata = {
  "name": "${metadata.name}",
  "description": "${metadata.description}",
  "type": "${metadata.type}"
};

export const baseRules = {
  "type": "${metadata.type}",
  "chirality": "none",
  "vectors": [],
  "relativePositions": [],
  "focusPoints": [${landmark1}, ${landmark2}]
};

/**
 * Custom gesture detection using real-world unit calibration.
 * @param {object[]} landmarks - 2D screen-space landmarks from MediaPipe.
 * @param {object[]} worldLandmarks - 3D world-space landmarks (not used).
 * @param {number} tolerance - The required confidence threshold from the UI (0.0 to 1.0).
 * @returns {{detected: boolean, confidence: number, requiredConfidence: number}} The detection result.
 */
export function ${checkFnName}(landmarks, worldLandmarks, tolerance = 0.5) {
  // --- Easily Editable Calibration Constants ---
  const REFERENCE_LANDMARK_1 = ${ref1};
  const REFERENCE_LANDMARK_2 = ${ref2};
  const KNOWN_REAL_WORLD_DISTANCE_CM = ${knownDist};
  // -----------------------------------------

  const p1_idx = ${landmark1};
  const p2_idx = ${landmark2};

  if (!landmarks || landmarks.length < Math.max(p1_idx, p2_idx, REFERENCE_LANDMARK_1, REFERENCE_LANDMARK_2) + 1) {
    return { detected: false, confidence: 0 };
  }

  const p1 = landmarks[p1_idx];
  const p2 = landmarks[p2_idx];
  const ref1 = landmarks[REFERENCE_LANDMARK_1];
  const ref2 = landmarks[REFERENCE_LANDMARK_2];

  if (!p1 || !p2 || !ref1 || !ref2) {
    return { detected: false, confidence: 0 };
  }

  const vectorDistance = (v1, v2) => {
    const dx = v1.x - v2.x;
    const dy = v1.y - v2.y;
    return Math.sqrt(dx * dx + dy * dy);
  };

  const measuredPixelDistance = vectorDistance(p1, p2);
  const referencePixelDistance = vectorDistance(ref1, ref2);

  if (referencePixelDistance < 1e-6) {
    return { detected: false, confidence: 0 };
  }
  
  const pixelsPerCm = referencePixelDistance / KNOWN_REAL_WORLD_DISTANCE_CM;
  const estimatedDistanceCm = measuredPixelDistance / pixelsPerCm;

  // --- Map the calculated distance to a confidence score ---
  const minDistanceCm = ${minDistance}; // Calibrated minimum distance in CM
  const maxDistanceCm = ${maxDistance}; // Calibrated maximum distance in CM

  let confidence = 0.0;
  if (estimatedDistanceCm > minDistanceCm && maxDistanceCm > minDistanceCm) {
    confidence = (estimatedDistanceCm - minDistanceCm) / (maxDistanceCm - minDistanceCm);
  }

  confidence = Math.max(0, Math.min(1.0, confidence));

  return {
    detected: confidence >= tolerance,
    confidence: confidence,
    requiredConfidence: tolerance
  };
}
`;
  }

  /**
   * Extracts features for a STATIC gesture from multiple samples.
   */
  extract(samples, selectedLandmarkIndices = new Set()) {
    if (!samples || samples.length < MIN_SAMPLES_FOR_STATISTICAL_RELEVANCE) {
      console.warn(`[FeatureExtractor] Need ${MIN_SAMPLES_FOR_STATISTICAL_RELEVANCE} samples, got ${samples?.length || 0}.`);
      return null;
    }
    
    const allPotentialVectorRules = [];
    const allPotentialPositionRules = [];
    const landmarksCount = this.#gestureType === 'hand' ? 21 : 33;
    const recordedChirality = this.#gestureType === 'hand' ? this.#getChirality(samples[0].landmarks2d) : 'none';

    for (let i = 0; i < landmarksCount; i++) {
        for (let j = i + 1; j < landmarksCount; j++) {
            const p1Index = i, p2Index = j;
            
            const vectors = samples.map(s => {
                const worldLandmarks = s.landmarks3d;
                if (!worldLandmarks || !worldLandmarks[p1Index] || !worldLandmarks[p2Index]) return null;
                const vec = VectorUtils.subtract(worldLandmarks[p1Index], worldLandmarks[p2Index]);
                return VectorUtils.normalize(vec);
            }).filter(Boolean);

            if (vectors.length >= MIN_SAMPLES_FOR_STATISTICAL_RELEVANCE) {
                const xStats = this.#calculateStats(vectors.map(v => v.x));
                const yStats = this.#calculateStats(vectors.map(v => v.y));
                const zStats = this.#calculateStats(vectors.map(v => v.z));
                const isPrioritized = selectedLandmarkIndices.size > 0 && (selectedLandmarkIndices.has(p1Index) || selectedLandmarkIndices.has(p2Index));
                allPotentialVectorRules.push({ 
                    points: { p1: p1Index, p2: p2Index }, stats: { x: xStats, y: yStats, z: zStats },
                    totalVariation: xStats.variation + yStats.variation + zStats.variation, priority: isPrioritized ? 0 : 1
                });
            }

            const positions = samples.map(s => {
                const screenLandmarks = s.landmarks2d;
                if (!screenLandmarks || !screenLandmarks[p1Index] || !screenLandmarks[p2Index]) return null;
                return { dx: screenLandmarks[p1Index].x - screenLandmarks[p2Index].x, dy: screenLandmarks[p1Index].y - screenLandmarks[p2Index].y };
            }).filter(Boolean);

            if (positions.length >= MIN_SAMPLES_FOR_STATISTICAL_RELEVANCE) {
                const dxStats = this.#calculateStats(positions.map(p => p.dx));
                const dyStats = this.#calculateStats(positions.map(p => p.dy));
                if (dxStats.stdDev < 0.05) allPotentialPositionRules.push({ points: { p1: p1Index, p2: p2Index }, axis: 'x', stats: dxStats });
                if (dyStats.stdDev < 0.05) allPotentialPositionRules.push({ points: { p1: p1Index, p2: p2Index }, axis: 'y', stats: dyStats });
            }
        }
    }

    allPotentialVectorRules.sort((a, b) => (a.priority !== b.priority) ? a.priority - b.priority : a.totalVariation - b.totalVariation);
    const bestVectorRules = allPotentialVectorRules.slice(0, Math.max(8, Math.min(allPotentialVectorRules.length, 25)));
    
    const finalExtractedRules = { type: this.#gestureType, chirality: recordedChirality, vectors: [], relativePositions: [] };
    
    bestVectorRules.forEach(rule => {
        finalExtractedRules.vectors.push({ 
            p1: rule.points.p1, p2: rule.points.p2, 
            meanX: rule.stats.x.mean, stdDevX: rule.stats.x.stdDev,
            meanY: rule.stats.y.mean, stdDevY: rule.stats.y.stdDev,
            meanZ: rule.stats.z.mean, stdDevZ: rule.stats.z.stdDev,
        });
    });

    allPotentialPositionRules.sort((a,b) => a.stats.stdDev - b.stats.stdDev);
    finalExtractedRules.relativePositions = allPotentialPositionRules.slice(0, 5).map(rule => ({
        p1: rule.points.p1, p2: rule.points.p2, axis: rule.axis,
        mean: rule.stats.mean, stdDev: rule.stats.stdDev,
    }));

    if (finalExtractedRules.vectors.length === 0 && finalExtractedRules.relativePositions.length === 0) {
        console.warn("[FeatureExtractor] No valid rules could be generated.");
        return null;
    }
    
    const allUsedPoints = new Set([
        ...bestVectorRules.flatMap(r => [r.points.p1, r.points.p2]),
        ...finalExtractedRules.relativePositions.flatMap(r => [r.p1, r.p2])
    ]);
    const focusPoints = selectedLandmarkIndices.size > 0 ? Array.from(selectedLandmarkIndices) : Array.from(allUsedPoints);

    return { rules: finalExtractedRules, focusPoints };
  }
  
  /**
   * Generates a JS file for a STATIC gesture based on statistical analysis.
   */
  generateStaticGestureJsFileContent(definition) {
    const { metadata, rules, focusPoints } = definition;
    const finalRules = { ...rules, focusPoints: focusPoints || [] };
    const rulesJsonString = JSON.stringify(finalRules, null, 2);

    // REFACTORED: This now generates a very simple file containing only data.
    return `// Custom Gesture: ${metadata.name} (Type: ${metadata.type})
// Description: ${metadata.description}
// Generated by GestureVision Studio on ${new Date().toLocaleDateString()}
export const metadata = {
  "name": "${metadata.name}",
  "description": "${metadata.description}",
  "type": "${metadata.type}"
};

// This is a static gesture. The detection logic is handled by the core GestureUtils.
// This file only contains the unique, statistical data for this specific gesture.
export const baseRules = ${rulesJsonString};
`;
  }
}