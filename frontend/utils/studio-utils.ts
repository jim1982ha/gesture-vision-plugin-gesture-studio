/* FILE: extensions/plugins/gesture-vision-plugin-gesture-studio/frontend/utils/studio-utils.ts */
import type { SnapshotData } from '#frontend/types/index.js';
import type { GestureType, StudioSessionData } from '../GestureStudio.js';
import type { Landmark } from '@mediapipe/tasks-vision';

const MIN_SAMPLES_FOR_STATISTICAL_RELEVANCE = 3;

interface Vector3D { x: number; y: number; z: number; }
interface Stats { mean: number; stdDev: number; variation: number; }
interface VectorRule { p: { p1: number; p2: number; }; s: { x: Stats; y: Stats; z: Stats; }; v: number; prio: number; }
interface PositionRule { p: { p1: number; p2: number; }; axis: string; s: Stats; }
interface DynamicDefinition {
    metadata: StudioSessionData;
    landmark1: number;
    landmark2: number;
    minDistance: number;
    maxDistance: number;
    tolerance: number;
}
interface StaticDefinition {
    metadata: StudioSessionData;
    rules: object;
    focusPoints: number[];
    tolerance: number;
}
interface FinalStaticRules {
    type: GestureType,
    chirality: 'left' | 'right' | 'none',
    vectors: { p1: number, p2: number, x: Stats, y: Stats, z: Stats }[],
    relativePositions: { p1: number, p2: number, axis: string, mean: number, stdDev: number }[]
}

const VectorUtils = {
  subtract: (v1: Vector3D, v2: Vector3D): Vector3D => ({ x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z }),
  normalize: (v: Vector3D): Vector3D => {
    const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    return mag > 1e-6 ? { x: v.x / mag, y: v.y / mag, z: v.z / mag } : { x: 0, y: 0, z: 0 };
  },
};

export interface FeatureExtractorResult {
    rules: FinalStaticRules;
    focusPoints: number[];
}

export class FeatureExtractor {
  #gestureType: GestureType;
  constructor(gestureType: GestureType) {
    if (gestureType !== "hand" && gestureType !== "pose") {
      throw new Error("This feature extractor only supports 'hand' or 'pose' gestures.");
    }
    this.#gestureType = gestureType;
  }

  #calculateStats(values: number[]): Stats {
    if (values.length < 2) return { mean: values[0] || 0, stdDev: 0, variation: 0 };
    const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / (values.length -1);
    const stdDev = Math.sqrt(variance);
    const variation = mean > 1e-6 ? stdDev / mean : Infinity;
    return { mean, stdDev, variation };
  }

  #getChirality(landmarks: Landmark[] | null | undefined): 'left' | 'right' | 'none' {
    if (!landmarks || landmarks.length < 21) return 'none';
    return landmarks[17].x < landmarks[5].x ? 'right' : 'left';
  }
  
  generateDynamicGestureJsFileContent(definition: DynamicDefinition): string {
    const { metadata, landmark1, landmark2, minDistance, maxDistance } = definition;
    const checkFnName = metadata.type === 'pose' ? "checkPose" : "checkGesture";
    
    const [ref1, ref2, knownDist] = metadata.type === 'hand' 
      ? [5, 8, 9.0] 
      : [11, 12, 25.0];

    return `// Custom Gesture: ${metadata.name} (Type: ${metadata.type})
// Description: ${metadata.description}
// Generated by GestureVision Studio on ${new Date().toLocaleDateString()}
export const metadata = {
  "name": "${metadata.name}",
  "description": "${metadata.description}",
  "type": "${metadata.type}"
};

export const baseRules = {
  "type": "${metadata.type}",
  "chirality": "none",
  "vectors": [],
  "relativePositions": [],
  "focusPoints": [${landmark1}, ${landmark2}]
};

export function ${checkFnName}(landmarks, worldLandmarks, tolerance = 0.5) {
  const REFERENCE_LANDMARK_1 = ${ref1};
  const REFERENCE_LANDMARK_2 = ${ref2};
  const KNOWN_REAL_WORLD_DISTANCE_CM = ${knownDist};
  const p1_idx = ${landmark1};
  const p2_idx = ${landmark2};

  if (!landmarks || landmarks.length < Math.max(p1_idx, p2_idx, REFERENCE_LANDMARK_1, REFERENCE_LANDMARK_2) + 1) return { detected: false, confidence: 0 };

  const p1 = landmarks[p1_idx]; const p2 = landmarks[p2_idx];
  const ref1 = landmarks[REFERENCE_LANDMARK_1]; const ref2 = landmarks[REFERENCE_LANDMARK_2];
  if (!p1 || !p2 || !ref1 || !ref2) return { detected: false, confidence: 0 };

  const dist = (v1, v2) => Math.sqrt(Math.pow(v1.x - v2.x, 2) + Math.pow(v1.y - v2.y, 2));
  const measuredPx = dist(p1, p2); const refPx = dist(ref1, ref2);
  if (refPx < 1e-6) return { detected: false, confidence: 0 };
  
  const estDistCm = (measuredPx / refPx) * KNOWN_REAL_WORLD_DISTANCE_CM;
  const minCm = ${minDistance}; const maxCm = ${maxDistance};
  let confidence = 0.0;
  if (estDistCm > minCm && maxCm > minCm) confidence = (estDistCm - minCm) / (maxCm - minCm);
  confidence = Math.max(0, Math.min(1.0, confidence));

  return { detected: confidence >= tolerance, confidence, requiredConfidence: tolerance };
}`;
  }

  extract(samples: SnapshotData[], selectedLandmarkIndices: Set<number> = new Set()): FeatureExtractorResult | null {
    if (!samples || samples.length < MIN_SAMPLES_FOR_STATISTICAL_RELEVANCE) return null;
    
    const allVecRules: VectorRule[] = []; 
    const allPosRules: PositionRule[] = [];
    const landmarksCount = this.#gestureType === 'hand' ? 21 : 33;
    const chirality = this.#gestureType === 'hand' ? this.#getChirality(samples[0].landmarks2d) : 'none';

    for (let i = 0; i < landmarksCount; i++) {
        for (let j = i + 1; j < landmarksCount; j++) {
            const vectors = samples.map(s => {
                const worldLandmarks = s.landmarks3d;
                if (!worldLandmarks?.[i] || !worldLandmarks[j]) return null;
                return VectorUtils.normalize(VectorUtils.subtract(worldLandmarks[i], worldLandmarks[j]));
            }).filter((v): v is Vector3D => v !== null);

            if (vectors.length >= MIN_SAMPLES_FOR_STATISTICAL_RELEVANCE) {
                const isPrioritized = selectedLandmarkIndices.size > 0 && (selectedLandmarkIndices.has(i) || selectedLandmarkIndices.has(j));
                const x = this.#calculateStats(vectors.map(v => v.x));
                const y = this.#calculateStats(vectors.map(v => v.y));
                const z = this.#calculateStats(vectors.map(v => v.z));
                allVecRules.push({ p: { p1: i, p2: j }, s: { x, y, z }, v: x.variation + y.variation + z.variation, prio: isPrioritized ? 0 : 1 });
            }

            const positions = samples.map(s => {
                const screenLandmarks = s.landmarks2d;
                if (!screenLandmarks?.[i] || !screenLandmarks[j]) return null;
                return { dx: screenLandmarks[i].x - screenLandmarks[j].x, dy: screenLandmarks[i].y - screenLandmarks[j].y };
            }).filter((p): p is { dx: number, dy: number } => p !== null);

            if (positions.length >= MIN_SAMPLES_FOR_STATISTICAL_RELEVANCE) {
                const dx = this.#calculateStats(positions.map(p => p.dx));
                const dy = this.#calculateStats(positions.map(p => p.dy));
                if (dx.stdDev < 0.05) allPosRules.push({ p: { p1: i, p2: j }, axis: 'x', s: dx });
                if (dy.stdDev < 0.05) allPosRules.push({ p: { p1: i, p2: j }, axis: 'y', s: dy });
            }
        }
    }

    allVecRules.sort((a, b) => (a.prio - b.prio) || (a.v - b.v));
    const bestVecRules = allVecRules.slice(0, Math.max(8, Math.min(allVecRules.length, 25)));
    
    const rules: FinalStaticRules = { type: this.#gestureType, chirality, vectors: bestVecRules.map(r => ({ p1: r.p.p1, p2: r.p.p2, ...r.s })), relativePositions: [] };
    
    allPosRules.sort((a, b) => a.s.stdDev - b.s.stdDev);
    rules.relativePositions = allPosRules.slice(0, 5).map(r => ({ p1: r.p.p1, p2: r.p.p2, axis: r.axis, mean: r.s.mean, stdDev: r.s.stdDev }));

    if (rules.vectors.length === 0 && rules.relativePositions.length === 0) return null;
    
    const allUsedPoints = new Set([...bestVecRules.flatMap(r => [r.p.p1, r.p.p2]), ...rules.relativePositions.flatMap(r => [r.p1, r.p2])]);
    const focusPoints = selectedLandmarkIndices.size > 0 ? Array.from(selectedLandmarkIndices) : Array.from(allUsedPoints);

    return { rules, focusPoints };
  }
  
  generateStaticGestureJsFileContent(definition: StaticDefinition): string {
    const { metadata, rules, focusPoints } = definition;
    const finalRules = { ...(rules as object), focusPoints: focusPoints || [] };
    const rulesJsonString = JSON.stringify(finalRules, null, 2);

    return `// Custom Gesture: ${metadata.name} (Type: ${metadata.type})
// Description: ${metadata.description}
// Generated by GestureVision Studio on ${new Date().toLocaleDateString()}
export const metadata = {
  "name": "${metadata.name}",
  "description": "${metadata.description}",
  "type": "${metadata.type}"
};
export const baseRules = ${rulesJsonString};
`;
  }
}